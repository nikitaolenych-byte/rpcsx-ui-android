From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: RPCSX Team <team@rpcsx.dev>
Date: Sun, 2 Feb 2026 00:00:00 +0000
Subject: [PATCH 1/3] Add Cell BE (PS3) pattern recognition for LLVM IR

This patch modifies the LLVM IR generator to recognize typical
PowerPC/SPU code blocks characteristic of PS3 and mark them for
specialized optimization.

---
 llvm/include/llvm/Transforms/PS3/CellBEPatterns.h   | 156 ++++++++++
 llvm/lib/Transforms/PS3/CellBEPatternRecognition.cpp| 342 ++++++++++++++++++++
 llvm/lib/Transforms/PS3/CMakeLists.txt              |  18 ++
 3 files changed, 516 insertions(+)

diff --git a/llvm/include/llvm/Transforms/PS3/CellBEPatterns.h b/llvm/include/llvm/Transforms/PS3/CellBEPatterns.h
new file mode 100644
index 000000000000..1a2b3c4d5e6f
--- /dev/null
+++ b/llvm/include/llvm/Transforms/PS3/CellBEPatterns.h
@@ -0,0 +1,156 @@
+//===- CellBEPatterns.h - Cell BE Pattern Recognition -----------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares interfaces for Cell Broadband Engine pattern recognition
+// used in PS3 emulation optimization.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TRANSFORMS_PS3_CELLBEPATTERNS_H
+#define LLVM_TRANSFORMS_PS3_CELLBEPATTERNS_H
+
+#include "llvm/IR/PassManager.h"
+#include "llvm/Pass.h"
+
+namespace llvm {
+
+class Function;
+class Module;
+
+/// Pattern types recognized from PS3/Cell BE code
+enum class CellBEPatternType {
+  Unknown = 0,
+  /// SPU DMA transfer patterns (MFC commands)
+  SPU_DMA_Transfer,
+  /// SPU SIMD 128-bit vector operations
+  SPU_SIMD_Vector128,
+  /// SPU shuffle/permute patterns
+  SPU_Shuffle,
+  /// SPU branch hint patterns
+  SPU_BranchHint,
+  /// PPU VMX/AltiVec patterns
+  PPU_VMX_Vector,
+  /// PPU floating-point paired singles
+  PPU_FP_Paired,
+  /// RSX graphics command patterns
+  RSX_CommandBuffer,
+  /// Physics simulation patterns (common in games)
+  Physics_AABB_Collision,
+  Physics_RigidBody,
+  Physics_SoftBody,
+  /// Audio DSP patterns
+  Audio_DSP_Filter,
+  Audio_DSP_Reverb,
+  /// Texture processing patterns
+  Texture_Decode_DXT,
+  Texture_Decode_PVRTC,
+  /// Post-processing shader patterns
+  PostProcess_Bloom,
+  PostProcess_DOF,
+  PostProcess_MotionBlur
+};
+
+/// Metadata attached to recognized patterns
+struct CellBEPatternInfo {
+  CellBEPatternType Type;
+  unsigned Confidence;      // 0-100 confidence score
+  bool CanVectorize;        // Can be auto-vectorized
+  bool CanOffloadGPU;       // Suitable for GPU compute
+  unsigned EstimatedCycles; // Estimated PS3 cycle count
+  unsigned VectorWidth;     // Preferred vector width (128/256/512)
+};
+
+/// Pass to recognize Cell BE patterns in IR
+class CellBEPatternRecognitionPass
+    : public PassInfoMixin<CellBEPatternRecognitionPass> {
+public:
+  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);
+  
+  static bool isRequired() { return false; }
+};
+
+/// Analysis pass providing pattern information
+class CellBEPatternAnalysis : public AnalysisInfoMixin<CellBEPatternAnalysis> {
+  friend AnalysisInfoMixin<CellBEPatternAnalysis>;
+  static AnalysisKey Key;
+
+public:
+  using Result = SmallVector<CellBEPatternInfo, 8>;
+  
+  Result run(Function &F, FunctionAnalysisManager &AM);
+};
+
+/// Legacy pass interface
+class CellBEPatternRecognitionLegacyPass : public FunctionPass {
+public:
+  static char ID;
+  
+  CellBEPatternRecognitionLegacyPass() : FunctionPass(ID) {}
+  
+  bool runOnFunction(Function &F) override;
+  
+  void getAnalysisUsage(AnalysisUsage &AU) const override {
+    AU.setPreservesAll();
+  }
+};
+
+/// Helper class for pattern matching
+class CellBEPatternMatcher {
+public:
+  /// Check if instruction sequence matches SPU SIMD pattern
+  static bool matchesSPUSimdPattern(const Instruction *I);
+  
+  /// Check if basic block contains DMA transfer pattern
+  static bool containsDMAPattern(const BasicBlock *BB);
+  
+  /// Check if function contains physics simulation patterns
+  static bool containsPhysicsPattern(const Function *F);
+  
+  /// Estimate PS3 cycle count for instruction
+  static unsigned estimatePS3Cycles(const Instruction *I);
+  
+  /// Get recommended vector width for pattern
+  static unsigned getRecommendedVectorWidth(CellBEPatternType Type);
+  
+  /// Check if pattern is suitable for GPU offload
+  static bool isSuitableForGPUOffload(CellBEPatternType Type);
+};
+
+/// Command-line options
+extern cl::opt<bool> PS3PatternMatch;
+extern cl::opt<bool> PS3VectorizeAggressive;
+extern cl::opt<unsigned> PS3MinConfidence;
+
+} // namespace llvm
+
+#endif // LLVM_TRANSFORMS_PS3_CELLBEPATTERNS_H
+
diff --git a/llvm/lib/Transforms/PS3/CellBEPatternRecognition.cpp b/llvm/lib/Transforms/PS3/CellBEPatternRecognition.cpp
new file mode 100644
index 000000000000..2b3c4d5e6f7a
--- /dev/null
+++ b/llvm/lib/Transforms/PS3/CellBEPatternRecognition.cpp
@@ -0,0 +1,342 @@
+//===- CellBEPatternRecognition.cpp - Cell BE Pattern Recognition ---------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Transforms/PS3/CellBEPatterns.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/IntrinsicInst.h"
+#include "llvm/IR/Metadata.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/Debug.h"
+
+using namespace llvm;
+
+#define DEBUG_TYPE "cellbe-pattern"
+
+STATISTIC(NumPatternsRecognized, "Number of Cell BE patterns recognized");
+STATISTIC(NumVectorizableBlocks, "Number of blocks marked for vectorization");
+STATISTIC(NumGPUOffloadCandidates, "Number of GPU offload candidates");
+
+cl::opt<bool> PS3PatternMatch(
+    "ps3-pattern-match", cl::init(true), cl::Hidden,
+    cl::desc("Enable Cell BE pattern matching for PS3 emulation"));
+
+cl::opt<bool> PS3VectorizeAggressive(
+    "ps3-vectorize-aggressive", cl::init(false), cl::Hidden,
+    cl::desc("Enable aggressive vectorization for PS3 patterns"));
+
+cl::opt<unsigned> PS3MinConfidence(
+    "ps3-min-confidence", cl::init(70), cl::Hidden,
+    cl::desc("Minimum confidence threshold for pattern recognition (0-100)"));
+
+AnalysisKey CellBEPatternAnalysis::Key;
+char CellBEPatternRecognitionLegacyPass::ID = 0;
+
+/// Pattern signatures for common PS3 code constructs
+namespace {
+
+// SPU instruction patterns (translated to IR)
+constexpr unsigned SPU_SHUFFLE_MASK = 0x1B;  // shufb pattern
+constexpr unsigned SPU_ROTATE_MASK = 0x0F;   // rotqby pattern
+
+// VMX/AltiVec patterns
+constexpr unsigned VMX_PERM_MASK = 0x1F;
+constexpr unsigned VMX_MADD_PATTERN = 0x2E;
+
+// Physics patterns (AABB, rigid body)
+constexpr unsigned PHYSICS_DOT_PRODUCT = 0x40;
+constexpr unsigned PHYSICS_CROSS_PRODUCT = 0x41;
+constexpr unsigned PHYSICS_NORMALIZE = 0x42;
+
+/// Check if type is 128-bit vector (common in PS3)
+bool is128BitVector(Type *Ty) {
+  if (auto *VecTy = dyn_cast<FixedVectorType>(Ty))
+    return VecTy->getPrimitiveSizeInBits() == 128;
+  return false;
+}
+
+/// Check for SPU shuffle pattern
+bool matchShufflePattern(const ShuffleVectorInst *SVI) {
+  ArrayRef<int> Mask = SVI->getShuffleMask();
+  if (Mask.size() != 4 && Mask.size() != 8 && Mask.size() != 16)
+    return false;
+  
+  // Check for common SPU shuffle patterns
+  // Pattern 1: Byte reverse (common in endian conversion)
+  bool isByteReverse = true;
+  for (size_t i = 0; i < Mask.size() && isByteReverse; ++i) {
+    if (Mask[i] != static_cast<int>(Mask.size() - 1 - i))
+      isByteReverse = false;
+  }
+  if (isByteReverse) return true;
+  
+  // Pattern 2: Interleave (vperm style)
+  bool isInterleave = true;
+  for (size_t i = 0; i < Mask.size() / 2 && isInterleave; ++i) {
+    if (Mask[2*i] != static_cast<int>(i) || 
+        Mask[2*i+1] != static_cast<int>(Mask.size() + i))
+      isInterleave = false;
+  }
+  
+  return isInterleave;
+}
+
+/// Check for FMA pattern (common in physics/graphics)
+bool matchFMAPattern(const Instruction *I) {
+  // Look for: fadd(fmul(a, b), c) or fsub patterns
+  if (auto *FAdd = dyn_cast<BinaryOperator>(I)) {
+    if (FAdd->getOpcode() == Instruction::FAdd ||
+        FAdd->getOpcode() == Instruction::FSub) {
+      if (auto *FMul = dyn_cast<BinaryOperator>(FAdd->getOperand(0))) {
+        if (FMul->getOpcode() == Instruction::FMul)
+          return true;
+      }
+      if (auto *FMul = dyn_cast<BinaryOperator>(FAdd->getOperand(1))) {
+        if (FMul->getOpcode() == Instruction::FMul)
+          return true;
+      }
+    }
+  }
+  return false;
+}
+
+/// Analyze loop for physics patterns
+CellBEPatternType analyzePhysicsLoop(const Loop *L) {
+  unsigned DotProducts = 0;
+  unsigned CrossProducts = 0;
+  unsigned Normalizes = 0;
+  
+  for (const BasicBlock *BB : L->blocks()) {
+    for (const Instruction &I : *BB) {
+      if (matchFMAPattern(&I)) {
+        // FMA in specific patterns indicates physics
+        DotProducts++;
+      }
+      if (auto *SI = dyn_cast<ShuffleVectorInst>(&I)) {
+        // Cross product typically has specific shuffle
+        CrossProducts++;
+      }
+      if (auto *CI = dyn_cast<CallInst>(&I)) {
+        if (CI->getCalledFunction()) {
+          StringRef Name = CI->getCalledFunction()->getName();
+          if (Name.contains("sqrt") || Name.contains("rsqrt"))
+            Normalizes++;
+        }
+      }
+    }
+  }
+  
+  if (DotProducts >= 4 && Normalizes >= 1)
+    return CellBEPatternType::Physics_RigidBody;
+  if (DotProducts >= 2)
+    return CellBEPatternType::Physics_AABB_Collision;
+  
+  return CellBEPatternType::Unknown;
+}
+
+} // anonymous namespace
+
+bool CellBEPatternMatcher::matchesSPUSimdPattern(const Instruction *I) {
+  if (!I) return false;
+  
+  // Check for 128-bit vector operations
+  if (is128BitVector(I->getType()))
+    return true;
+  
+  // Check operands for 128-bit vectors
+  for (const Use &U : I->operands()) {
+    if (is128BitVector(U->getType()))
+      return true;
+  }
+  
+  return false;
+}
+
+bool CellBEPatternMatcher::containsDMAPattern(const BasicBlock *BB) {
+  // DMA patterns typically involve:
+  // 1. Address calculation with specific alignment
+  // 2. Memory operations with specific sizes (16, 128 bytes)
+  // 3. Fence/barrier operations
+  
+  unsigned AlignedLoads = 0;
+  unsigned AlignedStores = 0;
+  
+  for (const Instruction &I : *BB) {
+    if (auto *LI = dyn_cast<LoadInst>(&I)) {
+      if (LI->getAlign().value() >= 16)
+        AlignedLoads++;
+    }
+    if (auto *SI = dyn_cast<StoreInst>(&I)) {
+      if (SI->getAlign().value() >= 16)
+        AlignedStores++;
+    }
+  }
+  
+  // DMA-like pattern: multiple aligned memory operations
+  return (AlignedLoads + AlignedStores) >= 4;
+}
+
+bool CellBEPatternMatcher::containsPhysicsPattern(const Function *F) {
+  // Heuristic: physics functions typically have specific characteristics
+  StringRef Name = F->getName();
+  
+  // Name-based heuristic
+  if (Name.contains("physics") || Name.contains("collision") ||
+      Name.contains("rigid") || Name.contains("aabb") ||
+      Name.contains("ray") || Name.contains("intersect"))
+    return true;
+  
+  // Structure-based heuristic: look for vector math patterns
+  unsigned VectorOps = 0;
+  unsigned FMAOps = 0;
+  
+  for (const BasicBlock &BB : *F) {
+    for (const Instruction &I : BB) {
+      if (matchesSPUSimdPattern(&I))
+        VectorOps++;
+      if (matchFMAPattern(&I))
+        FMAOps++;
+    }
+  }
+  
+  // High density of vector/FMA ops suggests physics
+  return (VectorOps >= 10 && FMAOps >= 4);
+}
+
+unsigned CellBEPatternMatcher::estimatePS3Cycles(const Instruction *I) {
+  // Rough cycle estimates based on PS3 PPU/SPU timing
+  switch (I->getOpcode()) {
+  case Instruction::FMul:
+  case Instruction::FAdd:
+  case Instruction::FSub:
+    return 6;  // FPU latency
+  case Instruction::FDiv:
+    return 30; // Division is slow
+  case Instruction::Load:
+    return is128BitVector(I->getType()) ? 6 : 3;
+  case Instruction::Store:
+    return is128BitVector(I->getOperand(0)->getType()) ? 6 : 3;
+  case Instruction::Call:
+    return 20; // Function call overhead
+  default:
+    return 1;
+  }
+}
+
+unsigned CellBEPatternMatcher::getRecommendedVectorWidth(CellBEPatternType Type) {
+  switch (Type) {
+  case CellBEPatternType::SPU_SIMD_Vector128:
+  case CellBEPatternType::PPU_VMX_Vector:
+    return 128; // Native PS3 width
+  case CellBEPatternType::Physics_RigidBody:
+  case CellBEPatternType::Physics_AABB_Collision:
+    return 256; // Can benefit from wider vectors
+  case CellBEPatternType::PostProcess_Bloom:
+  case CellBEPatternType::PostProcess_DOF:
+    return 512; // Highly parallel, use SVE if available
+  default:
+    return 128;
+  }
+}
+
+bool CellBEPatternMatcher::isSuitableForGPUOffload(CellBEPatternType Type) {
+  switch (Type) {
+  case CellBEPatternType::Physics_RigidBody:
+  case CellBEPatternType::Physics_SoftBody:
+  case CellBEPatternType::PostProcess_Bloom:
+  case CellBEPatternType::PostProcess_DOF:
+  case CellBEPatternType::PostProcess_MotionBlur:
+  case CellBEPatternType::Texture_Decode_DXT:
+    return true;
+  default:
+    return false;
+  }
+}
+
+PreservedAnalyses CellBEPatternRecognitionPass::run(Function &F,
+                                                     FunctionAnalysisManager &AM) {
+  if (!PS3PatternMatch)
+    return PreservedAnalyses::all();
+  
+  LLVM_DEBUG(dbgs() << "CellBE: Analyzing function " << F.getName() << "\n");
+  
+  auto &LI = AM.getResult<LoopAnalysis>(F);
+  
+  SmallVector<CellBEPatternInfo, 8> Patterns;
+  
+  // Analyze each basic block
+  for (BasicBlock &BB : F) {
+    unsigned VectorOps = 0;
+    unsigned ShuffleOps = 0;
+    
+    for (Instruction &I : BB) {
+      if (CellBEPatternMatcher::matchesSPUSimdPattern(&I))
+        VectorOps++;
+      if (auto *SVI = dyn_cast<ShuffleVectorInst>(&I)) {
+        if (matchShufflePattern(SVI))
+          ShuffleOps++;
+      }
+    }
+    
+    if (VectorOps >= 4) {
+      CellBEPatternInfo Info;
+      Info.Type = CellBEPatternType::SPU_SIMD_Vector128;
+      Info.Confidence = std::min(100u, VectorOps * 10);
+      Info.CanVectorize = true;
+      Info.CanOffloadGPU = false;
+      Info.VectorWidth = 128;
+      
+      if (Info.Confidence >= PS3MinConfidence) {
+        Patterns.push_back(Info);
+        ++NumPatternsRecognized;
+        ++NumVectorizableBlocks;
+      }
+    }
+  }
+  
+  // Analyze loops for physics patterns
+  for (Loop *L : LI) {
+    CellBEPatternType PhysType = analyzePhysicsLoop(L);
+    if (PhysType != CellBEPatternType::Unknown) {
+      CellBEPatternInfo Info;
+      Info.Type = PhysType;
+      Info.Confidence = 80;
+      Info.CanVectorize = true;
+      Info.CanOffloadGPU = CellBEPatternMatcher::isSuitableForGPUOffload(PhysType);
+      Info.VectorWidth = CellBEPatternMatcher::getRecommendedVectorWidth(PhysType);
+      
+      Patterns.push_back(Info);
+      ++NumPatternsRecognized;
+      if (Info.CanOffloadGPU)
+        ++NumGPUOffloadCandidates;
+    }
+  }
+  
+  // Attach metadata to function for later passes
+  if (!Patterns.empty()) {
+    LLVMContext &Ctx = F.getContext();
+    SmallVector<Metadata *, 4> PatternMDs;
+    
+    for (const auto &P : Patterns) {
+      PatternMDs.push_back(MDString::get(Ctx, 
+          "ps3.pattern." + Twine(static_cast<int>(P.Type)).str()));
+    }
+    
+    F.setMetadata("ps3.patterns", MDNode::get(Ctx, PatternMDs));
+  }
+  
+  return PreservedAnalyses::all();
+}
+
diff --git a/llvm/lib/Transforms/PS3/CMakeLists.txt b/llvm/lib/Transforms/PS3/CMakeLists.txt
new file mode 100644
index 000000000000..3c4d5e6f7a8b
--- /dev/null
+++ b/llvm/lib/Transforms/PS3/CMakeLists.txt
@@ -0,0 +1,18 @@
+add_llvm_component_library(LLVMPS3Transforms
+  CellBEPatternRecognition.cpp
+  ARMAutoVectorization.cpp
+  HeterogeneousPipeline.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Transforms/PS3
+
+  DEPENDS
+  intrinsics_gen
+
+  LINK_COMPONENTS
+  Analysis
+  Core
+  Support
+  TransformUtils
+  Vectorize
+  )
--
2.43.0
